// Generated by CoffeeScript 1.6.2
/*
接龙算法的ai
*/


(function() {
  var copy_array, debug_data, equal_array, game, len_point, log, random;

  log = function(msg, flag) {
    if (flag == null) {
      flag = '';
    }
    return console.log(flag + JSON.stringify(msg));
  };

  copy_array = function(arr) {
    var t, x, _i, _len;

    t = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      x = arr[_i];
      t.push(x.slice(0));
    }
    return t;
  };

  equal_array = function(arr1, arr2) {
    var i, _i, _ref;

    if (arr1.length !== arr2.length) {
      return false;
    }
    for (i = _i = 0, _ref = arr1.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }
    return true;
  };

  len_point = function(p1, p2) {
    var len;

    len = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);
    return len;
  };

  debug_data = function(data) {
    var row, _i, _len, _results;

    log('debug_data');
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      row = data[_i];
      _results.push(log(row, 'data'));
    }
    return _results;
  };

  random = function(size) {
    var c, inverNum, n, rand, rand_array, t2, temp, tmp2, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _results;

    if (size == null) {
      size = 3;
    }
    rand = function(s, e) {
      return s + parseInt(Math.random() * (e - s + 1));
    };
    rand_array = function(arr) {
      var i, j, t, _i, _ref, _results;

      _results = [];
      for (i = _i = _ref = arr.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        j = rand(0, i);
        t = arr[i];
        arr[i] = arr[j];
        _results.push(arr[j] = t);
      }
      return _results;
    };
    inverNum = function(numArr) {
      var count, i, j, len, _i, _j, _ref, _ref1, _ref2;

      len = numArr.length;
      count = 0;
      for (i = _i = 0, _ref = len - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = _ref1 = i + 1, _ref2 = len - 1; _ref1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = _ref1 <= _ref2 ? ++_j : --_j) {
          if (numArr[j] > numArr[i]) {
            count++;
          }
        }
      }
      return count;
    };
    for (c = _i = 0; _i <= 100; c = ++_i) {
      t2 = (function() {
        _results = [];
        for (var _j = 0, _ref = size * size - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--){ _results.push(_j); }
        return _results;
      }).apply(this);
      rand_array(t2);
      n = inverNum(t2);
      if (n % 2 === 0) {
        temp = [];
        for (y = _k = 0, _ref1 = size - 1; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; y = 0 <= _ref1 ? ++_k : --_k) {
          tmp2 = [];
          for (x = _l = 0, _ref2 = size - 1; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; x = 0 <= _ref2 ? ++_l : --_l) {
            tmp2.push(t2[x + y * size]);
          }
          temp.push(tmp2);
        }
        return temp;
        break;
      }
      log(t2, '奇数');
    }
  };

  this.PintuAi = (function() {
    function PintuAi(game) {
      this.game = game;
      this.step = [];
      log('ai init');
      this.size = this.game.size;
      this.data = copy_array(this.game.data);
      this.ok_ring = [[1, 2, 3], [4, 0, 5], [7, 8, 6]];
      this.ring_link = [1, 2, 3, 5, 6, 8, 7, 4];
      this.ring = [[0, 0], [1, 0], [2, 0], [2, 1], [2, 2], [1, 2], [0, 2], [0, 1]];
      this.ok_data = [[1, 2, 3], [4, 5, 6], [7, 8, 0]];
      this.ok_ring = [];
    }

    PintuAi.prototype.start = function() {
      return this.start_ring();
    };

    PintuAi.prototype.get_pos = function(n, map) {
      var x, y, _i, _j;

      if (map == null) {
        map = this.data;
      }
      for (y = _i = 0; _i <= 2; y = ++_i) {
        for (x = _j = 0; _j <= 2; x = ++_j) {
          if (map[y][x] === n) {
            return [x, y];
          }
        }
      }
      return -1;
    };

    PintuAi.prototype.get_val = function(p) {
      return this.data[p[1]][p[0]];
    };

    PintuAi.prototype.make_path = function(start, end, black_point) {
      var black_set, len, len1, min_row, p, path, row, t, t1, try_path, _i, _j, _len, _len1;

      if (black_point == null) {
        black_point = [];
      }
      black_set = {};
      for (_i = 0, _len = black_point.length; _i < _len; _i++) {
        p = black_point[_i];
        black_set[p[0] + 'x' + p[1]] = 1;
      }
      t = start.slice(0);
      path = [];
      while (true) {
        path.push(t);
        len = len_point(t, end);
        if (len === 0) {
          break;
        }
        try_path = [];
        t1 = t.slice(0);
        t1[0]--;
        if (t1[0] >= 0 && !black_set[t1[0] + 'x' + t1[1]]) {
          len1 = len_point(t1, end);
          try_path.push([t1, len1]);
        }
        t1 = t.slice(0);
        t1[0]++;
        if (t1[0] < this.size && !black_set[t1[0] + 'x' + t1[1]]) {
          len1 = len_point(t1, end);
          try_path.push([t1, len1]);
        }
        t1 = t.slice(0);
        t1[1]++;
        if (t1[1] < this.size && !black_set[t1[0] + 'x' + t1[1]]) {
          len1 = len_point(t1, end);
          try_path.push([t1, len1]);
        }
        t1 = t.slice(0);
        t1[1]--;
        if (t1[1] >= 0 && !black_set[t1[0] + 'x' + t1[1]]) {
          len1 = len_point(t1, end);
          try_path.push([t1, len1]);
        }
        min_row = null;
        for (_j = 0, _len1 = try_path.length; _j < _len1; _j++) {
          row = try_path[_j];
          if (row[1] <= try_path[0][1]) {
            min_row = row;
          }
        }
        if (min_row === null) {
          log('min_row is null');
          break;
        }
        t = min_row[0];
      }
      log(['start', start, 'end', end, 'path', path], 'make_path');
      return path;
    };

    PintuAi.prototype.move_to = function(n, pos) {
      var i, n_pos, p, p2, path2, _i, _ref, _ref1, _results;

      n_pos = this.get_pos(n);
      if (equal_array(n_pos, pos)) {
        log([n_pos, pos], ' pos ');
        log([equal_array(n_pos, pos)]);
        return;
      }
      log(n_pos, 'to', pos, '最短路径');
      path2 = this.make_path(n_pos, pos);
      _results = [];
      for (i = _i = 0, _ref = path2.length - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        p = path2[i];
        p2 = path2[i + 1];
        log([p, 'to', p2], 'move');
        _ref1 = [this.data[p2[1]][p2[0]], this.data[p[1]][p[0]]], this.data[p[1]][p[0]] = _ref1[0], this.data[p2[1]][p2[0]] = _ref1[1];
        log('swap');
        _results.push(debug_data(this.data));
      }
      return _results;
    };

    PintuAi.prototype.is_corner = function(pos) {
      if (equal_array(pos, [0, 0])) {
        return true;
      }
      if (equal_array(pos, [0, this.size - 1])) {
        return true;
      }
      if (equal_array(pos, [this.size - 1, 0])) {
        return true;
      }
      if (equal_array(pos, [this.size - 1, this.size - 1])) {
        return true;
      }
      return false;
    };

    PintuAi.prototype.ring_next_point = function(p, offset) {
      var flag, i, pos, _i, _ref;

      if (offset == null) {
        offset = 1;
      }
      flag = 0;
      pos = -1;
      for (i = _i = 0, _ref = this.ring.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (equal_array(p, this.ring[i])) {
          pos = i;
          break;
        }
      }
      if (pos === -1) {
        throw new Error('找不到正确的点');
      }
      pos = pos + offset;
      pos = (pos + this.ring.length) % this.ring.length;
      log(['p', p, 'offset', offset, 'result', this.ring[pos]], 'ring_next_point');
      return this.ring[pos];
    };

    PintuAi.prototype.get_ring_path = function(start, end) {
      var flag, i, index, path, pos, pos2, _i, _j, _k, _l, _len, _m, _n, _ref, _ref1, _ref2, _results, _results1, _results2;

      flag = 0;
      pos = -1;
      pos2 = -1;
      for (i = _i = 0, _ref = this.ring.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (equal_array(start, this.ring[i])) {
          pos = i;
          break;
        }
      }
      for (i = _j = 0, _ref1 = this.ring.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        if (equal_array(end, this.ring[i])) {
          pos2 = i;
          break;
        }
      }
      if (pos === -1 || pos2 === -1) {
        throw new Error('pos点不在环上');
      }
      path = [];
      index = pos2 > pos ? index = (function() {
        _results = [];
        for (var _k = pos; pos <= pos2 ? _k <= pos2 : _k >= pos2; pos <= pos2 ? _k++ : _k--){ _results.push(_k); }
        return _results;
      }).apply(this) : index = (function() {
        _results2 = [];
        for (var _m = pos, _ref2 = this.ring.length - 1; pos <= _ref2 ? _m <= _ref2 : _m >= _ref2; pos <= _ref2 ? _m++ : _m--){ _results2.push(_m); }
        return _results2;
      }).apply(this).concat((function() {
        _results1 = [];
        for (var _l = 0; 0 <= pos2 ? _l <= pos2 : _l >= pos2; 0 <= pos2 ? _l++ : _l--){ _results1.push(_l); }
        return _results1;
      }).apply(this));
      for (_n = 0, _len = index.length; _n < _len; _n++) {
        i = index[_n];
        path.push(this.ring[i]);
      }
      return path;
    };

    PintuAi.prototype.ring_rota = function(data, start, end, offset) {
      var i, ring_path, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _results, _results1, _results2;

      if (offset == null) {
        offset = 1;
      }
      log('ring_rota');
      ring_path = this.get_ring_path(start, end);
      log(ring_path, 'ring_path');
      for (_i = 0, _len = ring_path.length; _i < _len; _i++) {
        i = ring_path[_i];
        log([i, data[i[1]][i[0]]], 'path');
      }
      log(ring_path);
      log((function() {
        _results = [];
        for (var _j = _ref = ring_path.length - 1; _ref <= 1 ? _j <= 1 : _j >= 1; _ref <= 1 ? _j++ : _j--){ _results.push(_j); }
        return _results;
      }).apply(this));
      if (offset > 0) {
        _results1 = [];
        for (i = _k = _ref1 = ring_path.length - 1; _ref1 <= 1 ? _k <= 1 : _k >= 1; i = _ref1 <= 1 ? ++_k : --_k) {
          _results1.push(this.swap(ring_path[i], ring_path[i - 1], data));
        }
        return _results1;
      } else {
        _results2 = [];
        for (i = _l = 0, _ref2 = ring_path.length - 2; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
          _results2.push(this.swap(ring_path[i], ring_path[i + 1], data));
        }
        return _results2;
      }
    };

    PintuAi.prototype.swap = function(p1, p2, map) {
      var len, _ref;

      if (map == null) {
        map = this.data;
      }
      log([p1, p2], 'swap p1 p2');
      len = len_point(p1, p2);
      if (len > 1) {
        throw new Error('swap point error swap:' + (p1[0] + 'x' + p1[1] + '<=>' + p2[0] + 'x' + p2[1]));
      }
      debug_data(map);
      if (map[p2[1]][p2[0]] !== 0 && map[p1[1]][p1[0]] !== 0) {
        throw new Error('swap need 0');
      }
      _ref = [map[p2[1]][p2[0]], map[p1[1]][p1[0]]], map[p1[1]][p1[0]] = _ref[0], map[p2[1]][p2[0]] = _ref[1];
      log('swap to');
      return debug_data(map);
    };

    PintuAi.prototype.move_one = function(n_index, n, ok_ring) {
      var i, move_len, next2, next_p, p, p2, p_prev, p_prev_next, path0, t_pos, t_pos2, _i;

      p = this.get_pos(n);
      log('=============');
      log(['set n', n, 'p', p], 'set');
      if (n === 1) {
        next_p = this.ring_next_point(p);
        if (this.is_corner(next_p)) {
          next_p = this.ring_next_point(next_p);
        }
        this.swap(next_p, [1, 1]);
        debug_data(this.data);
        path0 = this.get_ring_path(p, [0, 0]);
        log(path0, 'path0');
        move_len = path0.length - 2;
        for (i = _i = 0; 0 <= move_len ? _i <= move_len : _i >= move_len; i = 0 <= move_len ? ++_i : --_i) {
          this.ring_rota(this.data, this.ring_next_point(next_p), this.ring_next_point(p));
          p = next_p;
          next_p = this.ring_next_point(p);
          debug_data(this.data);
        }
        log(path0, 'path0');
        this.swap([1, 0], [1, 1]);
        debug_data(this.data);
        this.ok_ring.push(n);
        return;
      }
      p_prev = this.get_pos(this.ring_link[n_index - 1]);
      log(['p_prev', p_prev, 'value:', this.get_val(p_prev)]);
      p_prev_next = this.ring_next_point(p_prev);
      log(['p_prev_next', p_prev_next, 'value:', this.get_val(p_prev_next)]);
      if (this.data[p_prev_next[1]][p_prev_next[0]] === n) {
        log([n, 'num is ok ']);
        debug_data(this.data);
        return;
      }
      if (!this.is_corner(p)) {
        log([p, 'is not corner ']);
        this.swap(p, [1, 1]);
        if (!this.is_corner(p_prev_next)) {
          this.ring_rota(this.data, p_prev_next, p);
          return this.swap([1, 1], p_prev_next);
        } else {
          /* 目标 6
          data [1,2,3]
          data [8,0,5]
          data [6,4,7]
           ["p_prev",[2,1],"value:",5]
            ["p_prev_next",[2,2],"value:",7]
          */

          this.ring_rota(this.data, p_prev_next, p);
          this.ring_rota(this.data, p, p_prev_next);
          t_pos = this.ring_next_point(p_prev_next);
          this.ring_rota(this.data, t_pos, p);
          this.swap([1, 1], t_pos);
          t_pos2 = this.ring_next_point(this.ring_next_point(t_pos));
          this.swap(t_pos2, [1, 1]);
          this.ring_rota(this.data, t_pos2, t_pos, -1);
          this.swap(t_pos, [1, 1]);
          return;
          return die();
        }
      } else {
        log([p, 'is  corner ']);
        if (!this.is_corner(p_prev_next)) {
          this.swap(p_prev_next, [1, 1]);
          p2 = this.ring_next_point(p);
          this.ring_rota(this.data, p_prev_next, p2, -1);
          this.swap(p2, [1, 1]);
          p_prev = this.get_pos(this.ring_link[n_index - 1]);
          p_prev_next = this.ring_next_point(p_prev);
          log(['n', n, 'get_val', p_prev_next, this.get_val(p_prev_next)]);
          if (n === this.get_val(p_prev_next)) {
            log(['n', n, 'is_ok']);
            return;
          }
          return this.move_one(n_index, n, ok_ring);
        } else {
          p2 = this.ring_next_point(p_prev_next);
          this.swap(p2, [1, 1]);
          /*
          #整体逆时针 , 将要移动的数移动打中间
          #7 后面的数 进入中间
          # [1,2,3]
          # [8,0,5]
          # [6,4,7]
              转
          # [1,2,3]
          # [8,4,5]
          # [6,0,7]
          =>  235
              147    
              860
          6 到 5 后面
          235
          106
          874
          在转回来
          
          235
          176
          804
          =>
          123
          875
          046
          =>
          123
          405
          786
          */

          this.ring_rota(this.data, p2, p_prev_next);
          p_prev = this.get_pos(this.ring_link[n_index - 1]);
          log(['p_prev', p_prev, 'value:', this.get_val(p_prev)]);
          p_prev_next = this.ring_next_point(p_prev);
          log(' p_prev_next,ring_next_point(p_prev_next)');
          this.swap(p_prev_next, this.ring_next_point(p_prev_next));
          log('p_prev_next,[1,1]');
          this.swap(p_prev_next, [1, 1]);
          p = this.get_pos(n);
          log('p, [1,1]');
          this.swap(p, [1, 1]);
          this.ring_rota(this.data, p_prev_next, p);
          this.swap(p_prev_next, [1, 1]);
          next2 = this.ring_next_point(this.ring_next_point(p_prev_next));
          this.swap(next2, [1, 1]);
          this.ring_rota(this.data, next2, p_prev_next, -1);
          this.swap(p_prev_next, [1, 1]);
          return;
          return die();
        }
      }
    };

    PintuAi.prototype.debug_ring = function() {
      this.data = [[1, 2, 3], [8, 0, 5], [6, 4, 7]];
      return this.move_one(4, 6);
    };

    PintuAi.prototype.start_ring = function() {
      var n, n_index, _i, _ref, _results;

      return this.debug_ring();
      debug_data(this.data);
      log('init ring');
      this.move_to(0, [1, 1]);
      _results = [];
      for (n_index = _i = 0, _ref = this.ring_link.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; n_index = 0 <= _ref ? ++_i : --_i) {
        n = this.ring_link[n_index];
        _results.push(this.move_one(n_index, n, this.ok_ring));
      }
      return _results;
    };

    return PintuAi;

  })();

  game = new MockGame(3);

  game.start();

}).call(this);
